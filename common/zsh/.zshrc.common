# --- Shell ---
# Ensure $SHELL is set correctly when running zsh
[[ "$SHELL" != */zsh ]] && export SHELL=$(which zsh)

# --- XDG Base Directory ---
# Ensure consistent config paths across macOS/Linux
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# --- Path ---
# Local bin (sheldon, zoxide, mise, etc.)
[[ -d "$HOME/.local/bin" ]] && export PATH="$HOME/.local/bin:$PATH"

# Atuin
[[ -d "$HOME/.atuin/bin" ]] && export PATH="$HOME/.atuin/bin:$PATH"

# Mise
command -v mise &>/dev/null && eval "$(mise activate zsh)"

# Cargo
[[ -d "$HOME/.cargo/bin" ]] && export PATH="$HOME/.cargo/bin:$PATH"

# Dotfiles scripts
export PATH="$HOME/dotfiles/scripts:$PATH"

# Deno
export DENO_INSTALL="$HOME/.deno"
[[ -d "$DENO_INSTALL/bin" ]] && export PATH="$DENO_INSTALL/bin:$PATH"

# User bin
[[ -d "$HOME/bin" ]] && export PATH="$PATH:$HOME/bin"

# --- Completion Init (cached: full rebuild once per 24h) ---
autoload -Uz compinit
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# --- Conditional Aliases (runtime checks) ---
# ls -> eza
if command -v eza &>/dev/null; then
  alias ls="eza --icons --git"
  alias ll="eza --icons --git -l"
  alias la="eza --icons --git -la"
fi
alias l='ls -CF'

# Modern replacements
command -v bat &>/dev/null && alias cat="bat"
command -v rg &>/dev/null && alias grep="rg"
command -v fd &>/dev/null && alias find="fd"
command -v tldr &>/dev/null && alias man="tldr"
command -v procs &>/dev/null && alias ps="procs"
command -v sd &>/dev/null && alias sed="sd"
command -v dust &>/dev/null && alias du="dust"
command -v btm &>/dev/null && alias top="btm"
command -v rip &>/dev/null && alias rm="rip"

# --- Modern Tools Init (cross-platform) ---
# gh completion: static file in fpath (regenerate after gh upgrade: gh completion -s zsh > ~/.zsh/completions/_gh)
[[ -d "$HOME/.zsh/completions" ]] && fpath=("$HOME/.zsh/completions" $fpath)
command -v starship &>/dev/null && eval "$(starship init zsh)"
command -v zoxide &>/dev/null && eval "$(zoxide init zsh --cmd cd)"

# --- 1Password CLI ---
if command -v op &>/dev/null; then
  op_secret() {
    op read "$1" 2>/dev/null
  }

  export_op_secret() {
    local var_name="$1"
    local op_ref="$2"
    export "$var_name"="$(op read "$op_ref" 2>/dev/null)"
  }

  # Git user config from 1Password (run manually: setup_git_from_op)
  # Writes to ~/.gitconfig.local to avoid overwriting by dotfiles sync
  setup_git_from_op() {
    local name email
    name=$(op read "op://Personal/Git Config/name") || { echo "Failed to read name"; return 1; }
    email=$(op read "op://Personal/Git Config/email") || { echo "Failed to read email"; return 1; }
    cat > ~/.gitconfig.local << EOF
[user]
    name = $name
    email = $email
EOF
    echo "Git config updated: $name <$email>"
  }

fi

# --- History ---
HISTFILE="$HOME/.zsh_history"
HISTSIZE=50000
SAVEHIST=50000
setopt SHARE_HISTORY

# --- Yazi (file manager) ---
function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}

# --- Local bin ---
[[ -f "$HOME/.local/bin/env" ]] && . "$HOME/.local/bin/env"

# --- Claude Context helpers ---
# CLAUDE_CONTEXT: Claude通知システム用のコンテキスト情報を環境間で伝播

# 内部関数: 現在の環境からコンテキストを生成
_claude_context() {
  local project="${CLAUDE_PROJECT:-$(basename "$PWD")}"
  local device="$(hostname -s)"
  local workspace="" tmux_session="" tmux_window=""

  # tmux情報
  if [[ -n "$TMUX" ]]; then
    tmux_session=$(tmux display-message -p '#S' 2>/dev/null)
    tmux_window=$(tmux display-message -p '#I' 2>/dev/null)
  fi

  # 手動マッピングからworkspaceを取得
  local map_file="/tmp/claude_workspace_map.json"
  if [[ -f "$map_file" ]]; then
    local env_key=""
    if [[ -n "$TMUX" ]]; then
      env_key="tmux_${tmux_session}_${tmux_window}"
    elif [[ -n "$VSCODE_PID" ]]; then
      env_key="vscode_${VSCODE_PID}"
    fi
    if [[ -n "$env_key" ]]; then
      workspace=$(jq -r --arg key "$env_key" '.[$key].workspace // ""' "$map_file" 2>/dev/null)
    fi
  fi

  echo "{\"project\":\"$project\",\"device\":\"$device\",\"workspace\":\"$workspace\",\"tmux_session\":\"$tmux_session\",\"tmux_window\":\"$tmux_window\"}"
}

# Dockerコンテナ進入 (CLAUDE_CONTEXT 自動設定/継承)
# Usage: dexec <container> [command...]
# Example: dexec my-container bash
#          CLAUDE_PROJECT=myproject dexec container zsh
dexec() {
  local container="$1"
  [[ -z "$container" ]] && { echo "Usage: dexec <container> [command...]" >&2; return 1; }
  shift

  # 既存の CLAUDE_CONTEXT があれば継承、なければ新規生成
  local context="${CLAUDE_CONTEXT:-$(_claude_context)}"

  docker exec -it -e CLAUDE_CONTEXT="$context" "$container" "${@:-bash}"
}

# リモートSSH接続 (CLAUDE_CONTEXT 自動設定)
# Usage: rssh [ssh-options] <host> [command]
# Example: rssh remote-server
#          rssh -p 2222 user@remote-server
#          rssh remote-server "cd /app && ls"
rssh() {
  local context="$(_claude_context)"
  local args=()
  local host=""
  local cmd_start=-1

  # 引数解析: オプション、ホスト、コマンドを分離
  local i=1
  for arg in "$@"; do
    if [[ -z "$host" ]]; then
      if [[ "$arg" == -* ]]; then
        # オプション (-p, -i など)
        args+=("$arg")
        # 次の引数がオプションの値かチェック
        if [[ "$arg" =~ ^-[pioJLRDWFl]$ ]]; then
          # 値を持つオプション: 次の引数を待つ
          :
        fi
      elif [[ "${args[-1]:-}" =~ ^-[pioJLRDWFl]$ ]]; then
        # 前のオプションの値
        args+=("$arg")
      else
        # ホスト名
        host="$arg"
        args+=("$arg")
        cmd_start=$((i + 1))
      fi
    fi
    ((i++))
  done

  if [[ -z "$host" ]]; then
    echo "Usage: rssh [ssh-options] <host> [command]" >&2
    return 1
  fi

  # コマンド部分を取得
  local cmd=""
  if [[ $cmd_start -le $# ]]; then
    cmd="${@:$cmd_start}"
  fi

  if [[ -n "$cmd" ]]; then
    # コマンド指定あり: 環境変数を注入して実行
    ssh "${args[@]}" "export CLAUDE_CONTEXT='$context' && $cmd"
  else
    # インタラクティブ: リモートシェル起動時に設定
    ssh -t "${args[@]}" "export CLAUDE_CONTEXT='$context' && exec \$SHELL -l"
  fi
}
