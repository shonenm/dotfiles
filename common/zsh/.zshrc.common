# --- Shell ---
# Ensure $SHELL is set correctly when running zsh
[[ "$SHELL" != */zsh ]] && export SHELL=$(which zsh)

# --- XDG Base Directory ---
# Ensure consistent config paths across macOS/Linux
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# --- Path ---
# Local bin (sheldon, zoxide, mise, etc.)
[[ -d "$HOME/.local/bin" ]] && export PATH="$HOME/.local/bin:$PATH"

# Atuin
[[ -d "$HOME/.atuin/bin" ]] && export PATH="$HOME/.atuin/bin:$PATH"

# Mise
command -v mise &>/dev/null && eval "$(mise activate zsh)"

# Direnv
command -v direnv &>/dev/null && eval "$(direnv hook zsh)"

# Cargo
[[ -d "$HOME/.cargo/bin" ]] && export PATH="$HOME/.cargo/bin:$PATH"

# Dotfiles scripts
export PATH="$HOME/dotfiles/scripts:$PATH"

# Deno
export DENO_INSTALL="$HOME/.deno"
[[ -d "$DENO_INSTALL/bin" ]] && export PATH="$DENO_INSTALL/bin:$PATH"

# User bin
[[ -d "$HOME/bin" ]] && export PATH="$PATH:$HOME/bin"

# --- fzf (TokyoNight theme) ---
export FZF_DEFAULT_OPTS="
  --height=80%
  --layout=reverse
  --border=rounded
  --info=inline
  --color=fg:#c0caf5,bg:-1,hl:#bb9af7
  --color=fg+:#c0caf5,bg+:#283457,hl+:#7dcfff
  --color=info:#7aa2f7,prompt:#7dcfff,pointer:#7dcfff
  --color=marker:#9ece6a,spinner:#9ece6a,header:#9ece6a
  --bind='ctrl-d:half-page-down,ctrl-u:half-page-up'
"
export FZF_DEFAULT_COMMAND="fd --type f --hidden --exclude .git"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="fd --type d --hidden --exclude .git"

# --- forgit ---
# Rename conflicting aliases (gsp is used by zsh-abbr for 'git stash pop')
export forgit_stash_push="gspu"
# Stash viewer keybindings: pop, apply, drop with auto-reload
export FORGIT_STASH_FZF_OPTS='
  --bind="alt-p:reload(git stash pop $(cut -d: -f1 <<<{}) 1>/dev/null && git stash list)"
  --bind="alt-a:reload(git stash apply $(cut -d: -f1 <<<{}) 1>/dev/null && git stash list)"
  --bind="alt-d:reload(git stash drop $(cut -d: -f1 <<<{}) 1>/dev/null && git stash list)"
  --header="enter:show | alt-p:pop | alt-a:apply | alt-d:drop | ctrl-y:copy ref"
'

# --- Completion Init (cached: full rebuild once per 24h) ---
autoload -Uz compinit
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# --- Conditional Aliases (runtime checks) ---
# ls -> lsd (fallback: eza)
if command -v lsd &>/dev/null; then
  alias ls="lsd"
  alias ll="lsd -l"
  alias la="lsd -la"
elif command -v eza &>/dev/null; then
  alias ls="eza --icons --git"
  alias ll="eza --icons --git -l"
  alias la="eza --icons --git -la"
fi
alias l='ls -CF'

# Modern replacements
command -v rg &>/dev/null && alias grep="rg"
command -v fd &>/dev/null && alias find="fd"
command -v tldr &>/dev/null && alias man="tldr"
command -v sd &>/dev/null && alias sed="sd"
command -v dust &>/dev/null && alias du="dust"
command -v btm &>/dev/null && alias top="btm"
command -v rip &>/dev/null && alias rm="rip"
command -v viddy &>/dev/null && alias watch="viddy"
command -v doggo &>/dev/null && alias dig="doggo"
command -v xh &>/dev/null && alias http="xh"

# --- Modern Tools Init (cross-platform) ---
# gh completion: static file in fpath (regenerate after gh upgrade: gh completion -s zsh > ~/.zsh/completions/_gh)
[[ -d "$HOME/.zsh/completions" ]] && fpath=("$HOME/.zsh/completions" $fpath)
command -v starship &>/dev/null && eval "$(starship init zsh)"
command -v zoxide &>/dev/null && eval "$(zoxide init zsh --cmd cd)"

# --- Auto ls on cd (chpwd hook) ---
chpwd() {
  ls
}

# --- 1Password CLI ---
if command -v op &>/dev/null; then
  op_secret() {
    op read "$1" 2>/dev/null
  }

  export_op_secret() {
    local var_name="$1"
    local op_ref="$2"
    export "$var_name"="$(op read "$op_ref" 2>/dev/null)"
  }

  # Git user config from 1Password (run manually: setup_git_from_op)
  # Writes to ~/.gitconfig.local to avoid overwriting by dotfiles sync
  setup_git_from_op() {
    local name email
    name=$(op read "op://Personal/Git Config/name") || { echo "Failed to read name"; return 1; }
    email=$(op read "op://Personal/Git Config/email") || { echo "Failed to read email"; return 1; }
    cat > ~/.gitconfig.local << EOF
[user]
    name = $name
    email = $email
EOF
    echo "Git config updated: $name <$email>"
  }

fi

# --- History ---
HISTFILE="$HOME/.zsh_history"
HISTSIZE=50000
SAVEHIST=50000
setopt SHARE_HISTORY

# --- Yazi (file manager) ---
function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}

# --- ghq (repository manager) ---
if command -v ghq &>/dev/null && command -v fzf &>/dev/null; then
  repo() {
    local selected
    selected=$(ghq list | fzf --query="${1:-}" \
      --preview "bat --style=plain --color=always $(ghq root)/{}/README.md 2>/dev/null || eza --icons -la $(ghq root)/{} 2>/dev/null || ls -la $(ghq root)/{}" \
      --preview-window=right:50%:wrap \
      --prompt="repo> " \
      --height=80%)
    if [[ -n "$selected" ]]; then
      cd "$(ghq root)/$selected"
    fi
  }
fi

# --- Local bin ---
[[ -f "$HOME/.local/bin/env" ]] && . "$HOME/.local/bin/env"

# --- Claude Context helpers ---
# CLAUDE_CONTEXT: Claude通知システム用のコンテキスト情報を環境間で伝播

# 内部関数: 現在の環境からコンテキストを生成
_claude_context() {
  local project="${CLAUDE_PROJECT:-$(basename "$PWD")}"
  local device="$(hostname -s)"
  local workspace="" tmux_session="" tmux_window=""

  # tmux情報
  if [[ -n "$TMUX" ]]; then
    tmux_session=$(tmux display-message -p '#S' 2>/dev/null)
    tmux_window=$(tmux display-message -p '#I' 2>/dev/null)
  fi

  # 手動マッピングからworkspaceを取得
  local map_file="/tmp/claude_workspace_map.json"
  if [[ -f "$map_file" ]]; then
    local env_key=""
    if [[ -n "$TMUX" ]]; then
      env_key="tmux_${tmux_session}_${tmux_window}"
    elif [[ -n "$VSCODE_PID" ]]; then
      env_key="vscode_${VSCODE_PID}"
    fi
    if [[ -n "$env_key" ]]; then
      workspace=$(jq -r --arg key "$env_key" '.[$key].workspace // ""' "$map_file" 2>/dev/null)
    fi
  fi

  echo "{\"project\":\"$project\",\"device\":\"$device\",\"workspace\":\"$workspace\",\"tmux_session\":\"$tmux_session\",\"tmux_window\":\"$tmux_window\"}"
}

# Dockerコンテナ進入 (CLAUDE_CONTEXT 自動設定/継承)
# Usage: dexec <container> [command...]
# Example: dexec my-container bash
#          CLAUDE_PROJECT=myproject dexec container zsh
dexec() {
  local container="$1"
  [[ -z "$container" ]] && { echo "Usage: dexec <container> [command...]" >&2; return 1; }
  shift

  # 既存の CLAUDE_CONTEXT があれば継承、なければ新規生成
  local context="${CLAUDE_CONTEXT:-$(_claude_context)}"

  docker exec -it -e CLAUDE_CONTEXT="$context" "$container" "${@:-bash}"
}

# リモートSSH接続 (CLAUDE_CONTEXT 自動設定)
# Usage: rssh [ssh-options] <host> [command]
# Example: rssh remote-server
#          rssh -p 2222 user@remote-server
#          rssh remote-server "cd /app && ls"
rssh() {
  local context="$(_claude_context)"
  local args=()
  local host=""
  local cmd_start=-1

  # 引数解析: オプション、ホスト、コマンドを分離
  local i=1
  for arg in "$@"; do
    if [[ -z "$host" ]]; then
      if [[ "$arg" == -* ]]; then
        # オプション (-p, -i など)
        args+=("$arg")
        # 次の引数がオプションの値かチェック
        if [[ "$arg" =~ ^-[pioJLRDWFl]$ ]]; then
          # 値を持つオプション: 次の引数を待つ
          :
        fi
      elif [[ "${args[-1]:-}" =~ ^-[pioJLRDWFl]$ ]]; then
        # 前のオプションの値
        args+=("$arg")
      else
        # ホスト名
        host="$arg"
        args+=("$arg")
        cmd_start=$((i + 1))
      fi
    fi
    ((i++))
  done

  if [[ -z "$host" ]]; then
    echo "Usage: rssh [ssh-options] <host> [command]" >&2
    return 1
  fi

  # コマンド部分を取得
  local cmd=""
  if [[ $cmd_start -le $# ]]; then
    cmd="${@:$cmd_start}"
  fi

  if [[ -n "$cmd" ]]; then
    # コマンド指定あり: 環境変数を注入して実行
    ssh "${args[@]}" "export CLAUDE_CONTEXT='$context' && $cmd"
  else
    # インタラクティブ: リモートシェル起動時に設定
    ssh -t "${args[@]}" "export CLAUDE_CONTEXT='$context' && exec \$SHELL -l"
  fi
}

# リモート接続 (SSH + Docker + tmux をワンコマンドで)
# Usage: rcon [host:container | host] [tmux-session]
#   rcon                      → fzf でターゲット選択
#   rcon ailab:syntopic-dev   → 直接指定 (host:container)
#   rcon pi-500               → 直接指定 (host のみ)
#   rcon pi-500 dev           → セッション名を明示指定
# Targets for fzf: ~/.config/rcon/targets (1行1ターゲット: host:container or host)
rcon() {
  local target="$1" session="$2"

  if [[ -z "$target" ]]; then
    local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/rcon/targets"
    [[ ! -f "$config_file" ]] && { echo "rcon: config not found: $config_file" >&2; return 1; }
    target=$(command grep -v '^\s*#' "$config_file" | command grep -v '^\s*$' | fzf --prompt="rcon> ")
    [[ -z "$target" ]] && return 1
  fi

  local host container
  if [[ "$target" == *:* ]]; then
    host="${target%%:*}"
    container="${target#*:}"
  else
    host="$target"
  fi

  local context="${CLAUDE_CONTEXT:-$(_claude_context)}"

  local tmux_cmd
  if [[ -n "$session" ]]; then
    tmux_cmd="tmux attach-session -d -t $session 2>/dev/null || tmux new-session -s $session"
  else
    tmux_cmd="tmux attach-session -d 2>/dev/null || tmux new-session"
  fi

  if [[ -n "$container" ]]; then
    TERM=xterm-256color ssh -t "$host" "docker exec -it -e TERM=xterm-256color -e CLAUDE_CONTEXT='$context' $container sh -c '$tmux_cmd'"
  else
    TERM=xterm-256color ssh -t "$host" "export CLAUDE_CONTEXT='$context' && $tmux_cmd"
  fi
}
