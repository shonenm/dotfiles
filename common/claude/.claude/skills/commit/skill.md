---
name: commit
description: 現在のセッションで行った変更を論理単位ごとに分割し、適切なコミットメッセージで複数コミットを作成します。
user-invocable: true
arguments: "[all] [<path>...]"
---

# Commit - Git コミット作成

**現在のClaudeセッション内で行った変更のみ**を対象に、論理的な単位に分割して適切なコミットメッセージでコミットを作成します。

## 引数

| 引数 | 説明 |
|------|------|
| (なし) | セッション内で行った変更のみをコミット（デフォルト） |
| `all` | セッション外の変更も含め、すべての未コミット変更をコミット |
| `<path>...` | 指定したファイル/ディレクトリのみをコミット対象とする |

### 使用例

```bash
/commit                      # セッション内の全変更
/commit all                  # すべての未コミット変更
/commit src/                 # セッション内の src/ 以下のみ
/commit all src/             # src/ 以下のすべての変更
/commit file.ts utils.ts     # 指定ファイルのみ（セッション内）
/commit all common/nvim/     # common/nvim/ 以下のすべての変更
```

## 重要: 対象範囲

### デフォルトモード (`/commit`, `/commit <path>`)

このスキルは**現在の会話で自分（Claude）が行った変更のみ**をコミットします。
- 会話履歴から Edit/Write ツールで変更したファイルを特定する
- 会話開始前から存在していた未コミットの変更はコミットしない
- 他のセッションや手動で行われた変更はコミットしない
- 不明な変更がある場合はユーザーに確認する
- `<path>` 指定時は、セッション内変更かつ指定パスに含まれるもののみ

### 全変更モード (`/commit all`, `/commit all <path>`)

**すべての未コミット変更**を対象にコミットします。
- セッション内外を問わず、すべての変更をコミット対象とする
- 変更内容を確認し、論理単位ごとに分割してコミットする
- `.env`や認証情報などの機密ファイルは除外（ユーザーに警告）
- `<path>` 指定時は、指定パスに含まれる変更のみ

## 手順

1. **引数の解析**:
   - `all` が含まれているか → 全変更モード
   - `all` 以外の引数があるか → パスフィルタとして扱う
   - 例: `/commit all src/ lib/` → 全変更モード + `src/`, `lib/` のみ対象

2. **対象変更の特定**:
   - **デフォルトモード**: 会話履歴から Edit/Write ツールで変更・作成したファイル一覧と各変更の目的を確認
   - **allモード**: すべての未コミット変更を対象とする（セッション内外を問わない）

3. **git状態の確認** - 以下のコマンドを並列で実行:
   - `git status` - 未追跡ファイルと変更の確認（`-uall`フラグは使用しない）
   - `git diff --staged` - ステージ済みの変更を確認
   - `git diff` - 未ステージの変更を確認
   - `git log --oneline -5` - 最近のコミットメッセージのスタイルを確認

4. **対象ファイルの照合**:
   - **デフォルトモード**: git diff の結果とセッション内変更を照合し、セッションで変更したファイルのみを対象とする。セッション外の変更は除外。判断が難しい場合はユーザーに確認
   - **allモード**: git diff に表示されるすべての変更を対象とする
   - **パス指定時**: 上記で特定した対象から、指定パスに含まれるファイルのみに絞り込む

5. **変更の分析とコミット分割計画** - 対象の変更を論理単位ごとに分割:
   - 各ファイルの変更内容を確認し、関連する変更をグループ化
   - 1コミット = 1つの論理的な変更単位（機能追加、バグ修正、設定変更、ドキュメント更新など）
   - 異なる目的の変更は別コミットに分ける（例: 新機能とドキュメント更新は分離）
   - `.env`や認証情報などの機密ファイルはコミットしない
   - コミット順序は依存関係を考慮（コードの変更 → それに対するドキュメント更新）

6. **コミットメッセージの規約**:
   - フォーマット: `prefix(scope): 説明` （英語、小文字始まり）
   - prefix一覧:
     | prefix | 用途 |
     |--------|------|
     | `feat` | 新機能の追加 |
     | `imprv` | 既存機能の改善・強化 |
     | `fix` | バグ修正 |
     | `rfac` | リファクタリング（動作変更なし） |
     | `perf` | パフォーマンス改善 |
     | `docs` | ドキュメントのみの変更 |
     | `chore` | ビルド、CI、依存関係、その他雑務 |
   - scope: 変更対象のコンポーネント（`nvim`, `zsh`, `git`, `tmux`, `claude` 等）。複数にまたがる場合は省略可
   - 説明: 「何を」ではなく「なぜ」に焦点を当てた簡潔な英語（小文字始まり）

7. **コミットの実行** - 分割計画に従い、グループごとに順番にコミット:
   - 関連するファイルのみをステージング（`git add -A`や`git add .`は避け、ファイル名を指定）
   - HEREDOCを使用してコミットメッセージを渡す:
     ```bash
     git commit -m "$(cat <<'EOF'
     prefix(scope): 説明

     Co-Authored-By: Claude <noreply@anthropic.com>
     EOF
     )"
     ```
   - 各コミット後に次のグループをステージングして繰り返す
   - 全コミット完了後に`git status`と`git log --oneline`で成功を確認

## 注意事項

- ユーザーが明示的に要求しない限り、`--amend`は使用しない
- プリコミットフックが失敗した場合は、修正して新しいコミットを作成（amendしない）
- 変更がない場合は空コミットを作成しない
- `git push`はユーザーが明示的に要求しない限り実行しない
- 変更が単一の論理単位に収まる場合は1コミットで問題ない（無理に分割しない）
- デフォルトモードではセッション外の変更には触れない（`all`引数が指定された場合を除く）
